<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Title</title>
</head>
<body>
<script type="text/javascript">
    //    'use strict' 严格模式


    //    function Tab(name) { // 类中的this是当前实例
    //        var num = 100;
    //        this.name = name;
    //        this.say = function () {
    //            console.log(this.name);
    //        }
    //    }

    //    var tab = new Tab(); // 当做一个类执行 并且返回这个类的实例
    //    console.log(tab);
    //    Tab(10, 20); // 当做一个普通函数执行

    //    console.log(tab1 === tab2); // 每个实例之间都是一个单独的个体
    //    console.log(tab1);
    //    console.log(tab2);

    // 原型模式  解决实例之间 属性共享问题 原型是用来存储当前实例的公有属性和方法

    // 每一个函数数据类型（普通函数 类（内置类 和 自定义类））,都有一个天生自带的属性prototype(原型), 这个属性是一个对象数据类型的，存储当前类的实例的公用属性和方法

    // 在每一个prototype(原型)上, 有一个天生自带的属性constructor(构造函数),它的属性值指向当前这个函数本身（当前这个类）

    // 每一个对象数据类型(普通对象 实例 原型 函数)，都有一个自带属性__proto_指向所属类的原型

    // 所有对象数据类型 都是 Object这个基类的实例 （最顶层的类）


    function Tab(name) { // 类中的this是当前实例
//      var num = 100;
        this.name = name;

    }
    console.dir(Tab);
    console.log(Tab.prototype);
    console.log(Tab.prototype.constructor === Tab);


    // console.log(tab1.__proto__ === Tab.prototype);

    // 在Tab这个类的原型上为实例添加 公用属性和方法
    Tab.prototype.say = function () {
        console.log(this.name);
    };

    // console.log(Tab.prototype);

    var tab1 = new Tab('zhufeng');
    // console.log(tab1);

    // tab1.say();
    var tab2 = new Tab('javascript');
    // console.log(tab2);
    // tab2.say();
    //
    // console.log(tab1.__proto__ === tab2.__proto__); // true
    // console.log(tab1.__proto__ === Tab.prototype);
    // console.log(tab2.__proto__ === Tab.prototype);
    // console.log(tab1.say === tab2.say); // true


    // console.log({});

    // 原型链模式
    console.log(tab1);
    // tab1.say

    // 通过对象名.属性名查找时，首先查找自己的私有属性，如果私有属性中存在 则获取的是私有属性, 否则通过__proto__找到所属类原型上的公用属性和方法，如果存在找到的是公有的属性和方法,否则继续通过原型__proto__ 一直找到Object.prototype 
</script>
</body>
</html>